# 《高性能 JavaScript》

> 本书承载着JavaScript性能方面最为宝贵的经验，从语言特性、数据结构、浏览器机理、网络传输等层面分析导致性能问题的原因，还介绍了多种工具来帮助我们提升开发过程和部署环节的工作

## 加载和执行

  **脚本位置**  

  浏览器使用单一线程处理UI刷新和JavaScript执行，页面生命周期内脚本执行可能会修改页面内容，浏览器会停止下来解析`<script>`标签(内嵌或外链)和执行，会阻塞页面渲染和交互。  

- **`编程提示 1`**：浏览器解析到`<body>`标签前不会渲染页面内容，而脚本会阻塞其他资源下载，故推荐将`<script>`标签尽可能放置到`<body>`标签底部

  **组织脚本**  
  
  从限制外链和内嵌脚本的数量方向入手，也可以改善页面加载的性能效果

- **`编程提示 2`**：通过合并JS减少`<script>`标签数量，减小脚本大小也是一个方向，如使用webpack将公共模块抽取及异步加载模块，先只加载必须的代码再异步载入其余代码

  **无阻塞的脚本**

  无阻塞脚本指页面加载完成后(即触发`window.onload`事件)，才加载JavaScript，`<script>`标签中可添加`async`和`defer`属性用于并行下载脚本不产生阻塞，区别在于async是加载完成后自动执行(async间不保证执行顺序)，而defer需等待页面完成后执行(defer间按顺序执行)  
  可以使用JS动态创建脚本元素，监听脚本加载完成事件`script.onload`触发回调，IE中判断脚本加载完成使用`script.onreadystatechange`判断`readyState`取值是否为`loaded`或`complete`，如果同域内可以使用XHR对象请求JS文件当`xhr.readyState == 4`时赋值`script.text = xhr.responseText`再添加到页面执行

- **`编程提示 3`**：使用无阻塞方式加载JavaScript，`<script>`标签defer属性、动态创建脚本元素插入到页面执行

## 数据存取

  数据存储位置关系到数据的读取速度，JS中有四种基本的数据存取位置，总的来说字面量和局部变量的访问速度快于数组项和对象成员的访问速度  

   1. 字面量，JS中字面量有字符串、数字、布尔值、对象、数组、函数、正则表达式及特殊的null和undefined值，它们只代表自身不存储在特定位置
   2. 本地变量，使用关键字var定义的数据存储单元
   3. 数组元素，存储在JS数组对象内部，以数组为索引
   4. 对象成员，存储在JS对象内部，以字符串为索引

  **管理作用域**  

  每个JS函数都是Function对象的一个实例，其内部属性`[[Scope]]`包含了函数被创建的作用域中对象集合，这一集合称为函数的作用域链，执行函数时会创建执行上下文，遇到变量时会经过标识符解析即搜索执行环境中的作用域链查找同名标识符，如果名字相同的两个变量位于不同作用域那么就近优先，类似查找原型链般前者遮蔽后者  

  标识符解析是有代价的，全局变量总存在于执行环境作用域链的最末端读写最慢，而函数中读写局部变量最快  
  改变作用域链，`with`语句可以将传入的对象推入到作用域链首位，with内的局部变量会先从传入的对象检索；`try-catch`语句的catch字句类似，它将异常对象推入一个变量对象置顶于作用域链

  with语句、try-catch的catch字句及eval都是动态作用域，引擎无法静态分析代码以优化标识符查找，在有必要时才使用动态作用域
  闭包允许函数访问局部作用域(函数作用域)之外的数据，闭包内的`[[Scope]]`属性包含了与执行环境作用域链相同的对象的引用，这个引用不会被销毁除非闭包没有引用或被手动置为为null时

- **`编程提示 4`**：在未优化的JS引擎浏览器中，尽可能使用局部变量，如果某一跨作用域的值被引用一次以上，那么将它存储到局部变量，使用局部变量复制值(值的引用)，减少作用域链的检索路径

- **`编程提示 5`** try-catch的catch字句应该尽量简化，如将错误委托给一个`handleError(e)`函数处理以减少局部变量访问，try-catch应该只用于不确定的错误，如A函数中使用try包裹return [null, await promise()]，catch中return [error, res]

- **`编程提示 6`** 使用闭包应该注意是否频繁访问跨作用域的标识符，应该将常用的跨作用域变量存储在局部变量中然后直接访问局部变量

  **对象成员**
  
  对象成员包括属性和方法，被访问的成员对象引用函数时，该成员称为一个方法，引用非函数类型成员称为属性  

  JS对象基于原型，通过`__proto__`属性关联另一对象引用，因此对象成员可分为实例成员和原型成员，实例成员存在于对象实例中，原型成员则从对象原型继承而来  

- **`编程提示 7`** 搜索实例成员比字面量或局部变量中读取数据代价更高，加之其遍历原型链上的开销，导致性能损耗增加，使用`hasOwnProperty()`方法可判断对象是否包含特定实例成员，使用`in`操作符可判断对象是否包含特定属性，即搜索实例页搜索原型  

- **`编程提示 7`** 嵌套成员会导致JS引擎搜索所有对象成员，层级越深读取越慢，尽量少用，如`location.href`比`window.location.href`快，一般对象使用`.`访问符比`[]`访问快  
- **`编程提示 8`** 缓存对象成员值，使用局部变量替代属性读取，避免多次查找带来的性能开销

## DOM编程

  **浏览器中的DOM**  

  DOM操作是Web应用中常见的性能瓶颈，文档对象模型(DOM)和ECMAScrip在浏览器中是独立实现的，需要通过接口连接，访问DOM次数越多运行越慢  

  **DOM访问与修改**  

  使用`innerHTML`与DOM方法`document.createElement()`修改DOM相比性能相差无几，但innerHTML代码更为简洁，DOM更新还可使用节点克隆方法`element.cloneNode()`，可简化createElement的操作  

  HTML集合是包含了DOM节点引用的类数组对象，以`假定时时态`实时存在，与文档保持连接，文档对象更新则HTML集合对象更新，每次访问HTML集合都将重复执行查询过程即时只是访问集合length属性，返回HTML集合的有`document.getElementsByName()、document.getElementsByClassName()、document.getElementsByTagName()、document.images、document.links、document.forms、document.forms[0].elements`  

  遍历DOM最好为特定操作选择最高效API，诸如DOM元素属性chilNodes、firstChild和nextSibling并不区分元素节点和其他类型节点(注释和文本节点等)，一般只需要访问元素节点，所以可以使用更现代的API获取属性如children、firstElementChild、nextElementSibling；以及使用querySelector和querySelectorAll来查询符合选择器的元素节点，其中`querySelectorAll`返回的是支持迭代器的NodeList类数组对象，是静态集合不是像getElementsByClassName返回的HTMLList动态集合

- **`编程提示 8`** 不要在循环中访问或修改元素，使用局部变量存储修改内容，结束循环后一次写入，尽可能减少DOM访问次数把运算留着ECMAScript处理  

- **`编程提示 9`** 遍历HTML集合时需要缓存length，因为每次读取`HTMLCollection.length`都会更新，如果可以，可将HTML集合拷贝到数组，遍历和访问都更快，同时多次访问同一DOM属性或方法，最好使用局部变量缓存此成员  
- **`编程提示 10`** 使用更为高效的API获取DOM属性，使用直接获取元素节点的属性(如lastElementChild)或querySelectorAll等现代选择器API

  **重绘与重排**  

  浏览器在下载完资源后会解析并生成DOM数和渲染树数据结构，构建完成树后开始绘制(JavaScript-Style-Layout-Paint-Composite)，当元素几何和位置属性变化时浏览器会重新构造渲染树即重排reflow，之后重新绘制到屏幕上即重绘repaint  

  重排何时发生，根据改变的范围和程度，渲染树中对应部分需要重新计算，如滚动条出现会触发整个页面重排
  - 增删可见的DOM元素
  - 元素位置改变
  - 元素尺寸改变，包括边距、边框、宽高属性
  - 内容改变，如文本改变或图片被不同尺寸的图片替换
  - 页面渲染器初始化
  - 浏览器窗口尺寸改变
  
  渲染树变化的排队与刷新，浏览器会通过队列化修改并批量执行来优化重排过程，但你可能不经意间强制熟悉队列并要求任务立即执行，如获取元素布局信息的操作会导致队列刷新，`(offset|scroll|client)Top、(offset|scroll|client)Left、(offset|scroll|client)Width、(offset|scroll|client)Height、getComputedStyle()|currentStyle`等属性和方法需要返回最新布局信息，需要浏览器刷新队列触发重排以返回正确结果  

- **`编程提示 11`** 最小化重排和重绘，了解重排何时发生和渲染队列刷新，减少页面布局、几何属性、元素布局信息的操作以及不再布局信息改变时查询元素样式；合并多次DOM和样式的修改，如修改内联样式可以使用cssText一次性附加`el.style.cssText += '; border-left: 1px;';`，非内联则应该使用切换class类的方式；批量修改DOM，先将元素脱离文档流，在对其应用改变，最后元素放回文档中，display隐藏元素-应用修改-重新显示、文档判断fragment或cloneNode拷贝副本后修改替换原始元素；减少布局信息的获取次数，缓存布局信息最小化重排；让元素脱离动画流，使用绝对定位使动画元素脱离文档流后在进行动画，动画结束则恢复定位

  **事件委托**  

## 算法和流程控制

  **循环**  

  **条件语句**  

  **递归**  

## 字符串和正则表达式

  **字符串连接**  

  **正则表达式优化**  

  **去除字符串首尾空白**  

## 快速响应的用户界面

  **使用定时器让出时间片段**  

  **Web Workers**  

## Ajax

  **数据传输**  

  **数据格式**  

  **Ajax性能指南**  

## 编程实践

  **避免双重求值**  

  **使用Objective/Array直接量**  

  **避免重复工作**  

  **使用速度快的部分**  

## 构建并部署高性能JavaScript应用

## 工具
